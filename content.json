{"meta":{"title":"无名小站","subtitle":"欢迎来到这里！","description":"随便记录点东西","author":"Yan Ximin","url":"http://blog.yanximin.site"},"pages":[{"title":"","date":"2018-04-10T12:47:46.000Z","updated":"2018-04-10T12:47:46.000Z","comments":true,"path":"README.html","permalink":"http://blog.yanximin.site/README.html","excerpt":"","text":"yanximin.github.io我的个人博客 特性给予Hexo和Indigo搭建！"},{"title":"","date":"2018-04-08T14:10:18.000Z","updated":"2018-04-08T14:10:18.000Z","comments":false,"path":"tags/index.html","permalink":"http://blog.yanximin.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"本博客由VPS迁移至Github","slug":"vps-to-github","date":"2018-04-09T13:28:41.000Z","updated":"2018-04-09T14:04:08.000Z","comments":true,"path":"2018/04/09/vps-to-github/","link":"","permalink":"http://blog.yanximin.site/2018/04/09/vps-to-github/","excerpt":"","text":"本博客使用hexo框架，之前一直把博客的服务器挂载在搬瓦工VPS上，通过ftp将写好的博客上传到VPS中，在用nodejs在VPS上编译，最后将静态的页面托管到Nginx上。最近发现VPS的服务马上就要到期了，怕给忘记续费，导致博客内容被清除。再者由于在服务器上操作过于繁琐，有了将博客迁移到github上的打算 迁移的过程主要分成这么几步 将VPS上数据下载到本地的电脑中由于使用了hexo框架，\b在使用nodejs编译的过程中会产生很多的临时文件。其实真正有用的只有三个文件夹（文件）：_config.yml，source，themes。其中_config.yml表示了网站的配置内容，比如标题、所有者等等；而source文件夹则\b保存了博客的markdown源文本；themes则保存了网站的主题。 本地编译网站静态内容主要重新按照Hexo和indigo的配置文档走了一遍： Hexo的配置文档：https://hexo.io/zh-cn/docs/ indigo的配置文档：https://github.com/yscoder/hexo-theme-indigo/wiki 按照文档步骤来就行了，千万不要跳过一些步骤，比方说可能会忘记敲安装nodejs的插件的命令。 将静态内容上传到Github上\b在Github上创建一个项目，项目的名称为【youname】.github.io\b，注意一定要已github.io结尾。在hexo的配置文件中，最后增加以下内容，就能将\b静态文件直接部署到Github上了。其中type和repo必填，其他两项选填。12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 输入$ npm install hexo-deployer-git --save安装hexo-deployer-git。最后使用hexo d就可以将内容自动添加到Github上。","categories":[],"tags":[{"name":"网站维护","slug":"网站维护","permalink":"http://blog.yanximin.site/tags/网站维护/"},{"name":"hexo","slug":"hexo","permalink":"http://blog.yanximin.site/tags/hexo/"}]},{"title":"斐讯路由器刷BREED和老毛子固件","slug":"feixun-roater","date":"2018-01-03T15:49:08.000Z","updated":"2018-04-08T13:13:55.000Z","comments":true,"path":"2018/01/03/feixun-roater/","link":"","permalink":"http://blog.yanximin.site/2018/01/03/feixun-roater/","excerpt":"","text":"刷BREED固件首先从 http://download.csdn.net/download/wjy329/10106922下载一键刷机。 点击箭头所指，打开刷机工具 这里可以看到界面，按照提示进行即可完成刷机，然后在打开的路由器设置界面中直接上传华硕固件即可完成。 刷完后路由器地址变成 192.168.123.1 用户名密码都为admin。（长按启动键插上电源，电脑网线连接LAN口即可进入BREED） 老毛子固件老毛子固件下载见http://www.right.com.cn/forum/thread-161324-1-1.html 下载地址点我，选择RT-AC54U-GPIO-1-PSG1208-64M_XXXX下载就行。 最后访问192.168.2.1的效果如下所示（图转）。","categories":[],"tags":[]},{"title":"new-github-project","slug":"new-github-project","date":"2017-11-17T21:08:24.000Z","updated":"2018-04-08T13:13:50.000Z","comments":true,"path":"2017/11/18/new-github-project/","link":"","permalink":"http://blog.yanximin.site/2017/11/18/new-github-project/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Java 中的异常和处理详解","slug":"java-exception","date":"2017-09-21T22:05:07.000Z","updated":"2018-04-08T13:13:51.000Z","comments":true,"path":"2017/09/22/java-exception/","link":"","permalink":"http://blog.yanximin.site/2017/09/22/java-exception/","excerpt":"","text":"转载自 http://www.importnew.com/26613.html 简介程序运行时，发生的不被期望的事件，它阻止了程序按照程序员的预期正常执行，这就是异常。异常发生时，是任程序自生自灭，立刻退出终止，还是输出错误给用户？或者用C语言风格：用函数返回值作为执行状态？。 Java提供了更加优秀的解决办法：异常处理机制。 异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，针对性地处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。Java中的异常可以是函数中的语句执行时引发的，也可以是程序员通过throw 语句手动抛出的，只要在Java程序中产生了异常，就会用一个对应类型的异常对象来封装异常，JRE就会试图寻找异常处理程序来处理异常。 Throwable类是Java异常类型的顶层父类，一个对象只有是 Throwable 类的（直接或者间接）实例，他才是一个异常对象，才能被异常处理机制识别。JDK中内建了一些常用的异常类，我们也可以自定义异常。 Java异常的分类和类结构图Java标准裤内建了一些通用的异常，这些类以Throwable为顶层父类。 Throwable又派生出Error类和Exception类。 错误：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。 异常：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。 Java异常的分类和类结构图 总体上我们根据Javac对异常的处理要求，将异常类分为2类。 非检查异常（unckecked exception）：Error 和 RuntimeException 以及他们的子类。javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。对于这些异常，我们应该修正代码，而不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。如除0错误ArithmeticException，错误的强制类型转换错误ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等。 检查异常（checked exception）：除了Error 和 RuntimeException的其它异常。javac强制要求程序员为这样的异常做预备处理工作（使用try…catch…finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException , IOException,ClassNotFoundException 等。 需要明确的是：检查和非检查是对于javac来说的，这样就很好理解和区分了。 初识异常下面的代码会演示2个异常类型：ArithmeticException 和 InputMismatchException。前者由于整数除0引发，后者是输入的数据不能被转换为int类型引发。 1234567891011121314151617181920212223242526272829303132333435363738394041package com.example;import java. util .Scanner ;public class AllDemo&#123; public static void main (String [] args ) &#123; System . out. println( \"----欢迎使用命令行除法计算器----\" ) ; CMDCalculate (); &#125; public static void CMDCalculate () &#123; Scanner scan = new Scanner ( System. in ); int num1 = scan .nextInt () ; int num2 = scan .nextInt () ; int result = devide (num1 , num2 ) ; System . out. println( \"result:\" + result) ; scan .close () ; &#125; public static int devide (int num1, int num2 )&#123; return num1 / num2 ; &#125;&#125;/***************************************** ----欢迎使用命令行除法计算器----0Exception in thread \"main\" java.lang.ArithmeticException : / by zero at com.example.AllDemo.devide( AllDemo.java:30 ) at com.example.AllDemo.CMDCalculate( AllDemo.java:22 ) at com.example.AllDemo.main( AllDemo.java:12 ) ----欢迎使用命令行除法计算器----rException in thread \"main\" java.util.InputMismatchException at java.util.Scanner.throwFor( Scanner.java:864 ) at java.util.Scanner.next( Scanner.java:1485 ) at java.util.Scanner.nextInt( Scanner.java:2117 ) at java.util.Scanner.nextInt( Scanner.java:2076 ) at com.example.AllDemo.CMDCalculate( AllDemo.java:20 ) at com.example.AllDemo.main( AllDemo.java:12 )*****************************************/ 异常是在执行某个函数时引发的，而函数又是层级调用，形成调用栈的，因为，只要一个函数发生了异常，那么他的所有的caller都会被异常影响。当这些被影响的函数以异常信息输出时，就形成的了异常追踪栈。 异常最先发生的地方，叫做异常抛出点。 从上面的例子可以看出，当devide函数发生除0异常时，devide函数将抛出ArithmeticException异常，因此调用他的CMDCalculate函数也无法正常完成，因此也发送异常，而CMDCalculate的caller——main 因为CMDCalculate抛出异常，也发生了异常，这样一直向调用栈的栈底回溯。这种行为叫做异常的冒泡，异常的冒泡是为了在当前发生异常的函数或者这个函数的caller中找到最近的异常处理程序。由于这个例子中没有使用任何异常处理机制，因此异常最终由main函数抛给JRE，导致程序终止。 上面的代码不使用异常处理机制，也可以顺利编译，因为2个异常都是非检查异常。但是下面的例子就必须使用异常处理机制，因为异常是检查异常。 代码中我选择使用throws声明异常，让函数的调用者去处理可能发生的异常。但是为什么只throws了IOException呢？因为FileNotFoundException是IOException的子类，在处理范围内。 123456789101112131415@Testpublic void testException() throws IOException&#123; //FileInputStream的构造函数会抛出FileNotFoundException FileInputStream fileIn = new FileInputStream(\"E:\\\\a.txt\"); int word; //read方法会抛出IOException while((word = fileIn.read())!=-1) &#123; System.out.print((char)word); &#125; //close方法会抛出IOException fileIn.clos&#125; 异常处理的基本语法在编写代码处理异常时，对于检查异常，有2种不同的处理方式：使用try…catch…finally语句块处理它。或者，在函数签名中使用throws 声明交给函数调用者caller去解决。 try…catch…finally语句块 123456789101112131415161718192021try&#123; //try块中放可能发生异常的代码。 //如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。 //如果发生异常，则尝试去匹配catch块。 &#125;catch(SQLException SQLexception)&#123; //每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7中可以将多个异常声明在一个catch中。 //catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。 //在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。 //如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器。 //如果try中没有发生异常，则所有的catch块将被忽略。 &#125;catch(Exception exception)&#123; //...&#125;finally&#123; //finally块通常是可选的。 //无论异常是否发生，异常是否匹配被处理，finally都会执行。 //一个try至少要有一个catch块，否则， 至少要有1个finally块。但是finally不是用来处理异常的，finally不会捕获异常。 //finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。 &#125; 需要注意的地方 1、try块中的局部变量和catch块中的局部变量（包括异常变量），以及finally中的局部变量，他们之间不可共享使用。 2、每一个catch块用于处理一个异常。异常匹配是按照catch块的顺序从上往下寻找的，只有第一个匹配的catch会得到执行。匹配时，不仅运行精确匹配，也支持父类匹配，因此，如果同一个try块下的多个catch异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面，这样保证每个catch块都有存在的意义。 3、java中，异常处理的任务就是将执行控制流从异常发生的地方转移到能够处理这种异常的地方去。也就是说：当一个函数的某条语句发生异常时，这条语句的后面的语句不会再执行，它失去了焦点。执行流跳转到最近的匹配的异常处理catch代码块去执行，异常被处理完后，执行流会接着在“处理了这个异常的catch代码块”后面接着执行。有的编程语言当异常被处理后，控制流会恢复到异常抛出点接着执行，这种策略叫做：resumption model of exception handling（恢复式异常处理模式 ）而Java则是让执行流恢复到处理了异常的catch块后接着执行，这种策略叫做：termination model of exception handling（终结式异常处理模式） 1234567891011public static void main(String[] args)&#123; try &#123; foo(); &#125;catch(ArithmeticException ae) &#123; System.out.println(\"处理异常\"); &#125;&#125;public static void foo()&#123; int a = 5/0; //异常抛出点 System.out.println(\"为什么还不给我涨工资!!!\"); //////////////////////不会执行&#125; throws 函数声明 throws声明：如果一个方法内部的代码会抛出检查异常（checked exception），而方法自己又没有完全处理掉，则javac保证你必须在方法的签名上使用throws关键字声明这些可能抛出的异常，否则编译不通过。 throws是另一种处理异常的方式，它不同于try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。 采取这种异常处理的原因可能是：方法本身不知道如何处理这样的异常，或者说让调用者处理更好，调用者需要为可能发生的异常负责。 1234public void foo() throws ExceptionType1 , ExceptionType2 ,ExceptionTypeN&#123; //foo内部可以抛出 ExceptionType1 , ExceptionType2 ,ExceptionTypeN 类的异常，或者他们的子类的异常对象。&#125; finally块finally块不管异常是否发生，只要对应的try执行了，则它一定也执行。只有一种方法让finally块不执行：System.exit()。因此finally块通常用来做资源释放操作：关闭文件，关闭数据库连接等等。 良好的编程习惯是：在try块中打开资源，在finally块中清理释放这些资源。 需要注意的地方: 1、finally块没有处理异常的能力。处理异常的只能是catch块。 2、在同一try…catch…finally块中 ，如果try中抛出异常，且有匹配的catch块，则先执行catch块，再执行finally块。如果没有catch块匹配，则先执行finally，然后去外面的调用者中寻找合适的catch块。 3、在同一try…catch…finally块中 ，try发生异常，且匹配的catch块中处理异常时也抛出异常，那么后面的finally也会执行：首先执行finally块，然后去外围调用者中寻找合适的catch块。 这是正常的情况，但是也有特例。关于finally有很多恶心，偏、怪、难的问题，我在本文最后统一介绍了，电梯速达-&gt;：finally块和return throw 异常抛出语句finally块不管异常是否发生，只要对应的try执行了，则它一定也执行。只有一种方法让finally块不执行：System.exit()。因此finally块通常用来做资源释放操作：关闭文件，关闭数据库连接等等。 良好的编程习惯是：在try块中打开资源，在finally块中清理释放这些资源。 需要注意的地方: 1、finally块没有处理异常的能力。处理异常的只能是catch块。 2、在同一try…catch…finally块中 ，如果try中抛出异常，且有匹配的catch块，则先执行catch块，再执行finally块。如果没有catch块匹配，则先执行finally，然后去外面的调用者中寻找合适的catch块。 3、在同一try…catch…finally块中 ，try发生异常，且匹配的catch块中处理异常时也抛出异常，那么后面的finally也会执行：首先执行finally块，然后去外围调用者中寻找合适的catch块。 这是正常的情况，但是也有特例。关于finally有很多恶心，偏、怪、难的问题，我在本文最后统一介绍了，电梯速达-&gt;：finally块和return throw 异常抛出语句throw exceptionObject 程序员也可以通过throw语句手动显式的抛出一个异常。throw语句的后面必须是一个异常对象。 throw 语句必须写在函数中，执行throw 语句的地方就是一个异常抛出点，它和由JRE自动形成的异常抛出点没有任何差别。 1234567public void save(User user)&#123; if(user == null) throw new IllegalArgumentException(\"User对象为空\"); //...... &#125; 异常的链化在一些大型的，模块化的软件开发中，一旦一个地方发生异常，则如骨牌效应一样，将导致一连串的异常。假设B模块完成自己的逻辑需要调用A模块的方法，如果A模块发生异常，则B也将不能完成而发生异常，但是B在抛出异常时，会将A的异常信息掩盖掉，这将使得异常的根源信息丢失。异常的链化可以将多个模块的异常串联起来，使得异常信息不会丢失。 异常链化:以一个异常对象为参数构造新的异常对象。新的异对象将包含先前异常的信息。这项技术主要是异常类的一个带Throwable参数的函数来实现的。这个当做参数的异常，我们叫他根源异常（cause）。 查看Throwable类源码，可以发现里面有一个Throwable字段cause，就是它保存了构造时传递的根源异常参数。这种设计和链表的结点类设计如出一辙，因此形成链也是自然的了。 12345678910111213141516public class Throwable implements Serializable &#123; private Throwable cause = this; public Throwable(String message, Throwable cause) &#123; fillInStackTrace(); detailMessage = message; this.cause = cause; &#125; public Throwable(Throwable cause) &#123; fillInStackTrace(); detailMessage = (cause==null ? null : cause.toString()); this.cause = cause; &#125; //........&#125; 下面是一个例子，演示了异常的链化：从命令行输入2个int，将他们相加，输出。输入的数不是int，则导致getInputNumbers异常，从而导致add函数异常，则可以在add函数中抛出 一个链化的异常。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public static void main(String[] args)&#123; System.out.println(\"请输入2个加数\"); int result; try &#123; result = add(); System.out.println(\"结果:\"+result); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125;&#125;//获取输入的2个整数返回private static List&lt;Integer&gt; getInputNumbers()&#123; List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); Scanner scan = new Scanner(System.in); try &#123; int num1 = scan.nextInt(); int num2 = scan.nextInt(); nums.add(new Integer(num1)); nums.add(new Integer(num2)); &#125;catch(InputMismatchException immExp)&#123; throw immExp; &#125;finally &#123; scan.close(); &#125; return nums;&#125; //执行加法计算private static int add() throws Exception&#123; int result; try &#123; List&lt;Integer&gt; nums =getInputNumbers(); result = nums.get(0) + nums.get(1); &#125;catch(InputMismatchException immExp)&#123; throw new Exception(\"计算失败\",immExp); /////////////////////////////链化:以一个异常对象为参数构造新的异常对象。 &#125; return result;&#125; /*请输入2个加数r 1java.lang.Exception: 计算失败 at practise.ExceptionTest.add(ExceptionTest.java:53) at practise.ExceptionTest.main(ExceptionTest.java:18)Caused by: java.util.InputMismatchException at java.util.Scanner.throwFor(Scanner.java:864) at java.util.Scanner.next(Scanner.java:1485) at java.util.Scanner.nextInt(Scanner.java:2117) at java.util.Scanner.nextInt(Scanner.java:2076) at practise.ExceptionTest.getInputNumbers(ExceptionTest.java:30) at practise.ExceptionTest.add(ExceptionTest.java:48) ... 1 more */ 自定义异常如果要自定义异常类，则扩展Exception类即可，因此这样的自定义异常都属于检查异常（checked exception）。如果要自定义非检查异常，则扩展自RuntimeException。 按照国际惯例，自定义的异常应该总是包含如下的构造函数： 一个无参构造函数 一个带有String参数的构造函数，并传递给父类的构造函数。 一个带有String参数和Throwable参数，并都传递给父类构造函数 一个带有Throwable 参数的构造函数，并传递给父类的构造函数。 下面是IOException类的完整源代码，可以借鉴。 12345678910111213141516171819202122232425public class IOException extends Exception&#123; static final long serialVersionUID = 7818375828146090155L; public IOException() &#123; super(); &#125; public IOException(String message) &#123; super(message); &#125; public IOException(String message, Throwable cause) &#123; super(message, cause); &#125; public IOException(Throwable cause) &#123; super(cause); &#125;&#125; 异常的注意事项1、当子类重写父类的带有 throws声明的函数时，其throws声明的异常必须在父类异常的可控范围内——用于处理父类的throws方法的异常处理器，必须也适用于子类的这个带throws方法 。这是为了支持多态。 例如，父类方法throws 的是2个异常，子类就不能throws 3个及以上的异常。父类throws IOException，子类就必须throws IOException或者IOException的子类。 至于为什么？我想，也许下面的例子可以说明。 1234567891011121314151617181920212223242526272829303132333435363738class Father&#123; public void start() throws IOException &#123; throw new IOException(); &#125;&#125; class Son extends Father&#123; public void start() throws Exception &#123; throw new SQLException(); &#125;&#125;/**********************假设上面的代码是允许的（实质是错误的）***********************/class Test&#123; public static void main(String[] args) &#123; Father[] objs = new Father[2]; objs[0] = new Father(); objs[1] = new Son(); for(Father obj:objs) &#123; //因为Son类抛出的实质是SQLException，而IOException无法处理它。 //那么这里的try。。catch就不能处理Son中的异常。 //多态就不能实现了。 try &#123; obj.start(); &#125;catch(IOException) &#123; //处理IOException &#125; &#125; &#125;&#125; 2、Java程序可以是多线程的。每一个线程都是一个独立的执行流，独立的函数调用栈。如果程序只有一个线程，那么没有被任何代码处理的异常 会导致程序终止。如果是多线程的，那么没有被任何代码处理的异常仅仅会导致异常所在的线程结束。 也就是说，Java中的异常是线程独立的，线程的问题应该由线程自己来解决，而不要委托到外部，也不会直接影响到其它线程的执行。 finally块和return首先一个不容易理解的事实：在 try块中即便有return，break，continue等改变执行流的语句，finally也会执行。 12345678910111213141516public static void main(String[] args)&#123; int re = bar(); System.out.println(re);&#125;private static int bar() &#123; try&#123; return 5; &#125; finally&#123; System.out.println(\"finally\"); &#125;&#125;/*输出：finally*/ 很多人面对这个问题时，总是在归纳执行的顺序和规律，不过我觉得还是很难理解。我自己总结了一个方法。用如下GIF图说明。 也就是说：try…catch…finally中的return 只要能执行，就都执行了，他们共同向同一个内存地址（假设地址是0×80）写入返回值，后执行的将覆盖先执行的数据，而真正被调用者取的返回值就是最后一次写入的。那么，按照这个思想，下面的这个例子也就不难理解了。 finally中的return 会覆盖 try 或者catch中的返回值。 123456789101112131415161718192021222324252627282930313233public static void main(String[] args) &#123; int result; result = foo(); System.out.println(result); /////////2 result = bar(); System.out.println(result); /////////2 &#125; @SuppressWarnings(\"finally\") public static int foo() &#123; trz&#123; int a = 5 / 0; &#125; catch (Exception e)&#123; return 1; &#125; finally&#123; return 2; &#125; &#125; @SuppressWarnings(\"finally\") public static int bar() &#123; try &#123; return 1; &#125;finally &#123; return 2; &#125; &#125; finally中的return会抑制（消灭）前面try或者catch块中的异常 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class TestException&#123; public static void main(String[] args) &#123; int result; try&#123; result = foo(); System.out.println(result); //输出100 &#125; catch (Exception e)&#123; System.out.println(e.getMessage()); //没有捕获到异常 &#125; try&#123; result = bar(); System.out.println(result); //输出100 &#125; catch (Exception e)&#123; System.out.println(e.getMessage()); //没有捕获到异常 &#125; &#125; //catch中的异常被抑制 @SuppressWarnings(\"finally\") public static int foo() throws Exception &#123; try &#123; int a = 5/0; return 1; &#125;catch(ArithmeticException amExp) &#123; throw new Exception(\"我将被忽略，因为下面的finally中使用了return\"); &#125;finally &#123; return 100; &#125; &#125; //try中的异常被抑制 @SuppressWarnings(\"finally\") public static int bar() throws Exception &#123; try &#123; int a = 5/0; return 1; &#125;finally &#123; return 100; &#125; &#125;&#125; finally中的异常会覆盖（消灭）前面try或者catch中的异常 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class TestException&#123; public static void main(String[] args) &#123; int result; try&#123; result = foo(); &#125; catch (Exception e)&#123; System.out.println(e.getMessage()); //输出：我是finaly中的Exception &#125; try&#123; result = bar(); &#125; catch (Exception e)&#123; System.out.println(e.getMessage()); //输出：我是finaly中的Exception &#125; &#125; //catch中的异常被抑制 @SuppressWarnings(\"finally\") public static int foo() throws Exception &#123; try &#123; int a = 5/0; return 1; &#125;catch(ArithmeticException amExp) &#123; throw new Exception(\"我将被忽略，因为下面的finally中抛出了新的异常\"); &#125;finally &#123; throw new Exception(\"我是finaly中的Exception\"); &#125; &#125; //try中的异常被抑制 @SuppressWarnings(\"finally\") public static int bar() throws Exception &#123; try &#123; int a = 5/0; return 1; &#125;finally &#123; throw new Exception(\"我是finaly中的Exception\"); &#125; &#125;&#125; 上面的3个例子都异于常人的编码思维，因此我建议： 不要在fianlly中使用return。 不要在finally中抛出异常。 减轻finally的任务，不要在finally中做一些其它的事情，finally块仅仅用来释放资源是最合适的。 将尽量将所有的return写在函数的最后面，而不是try … catch … finally中。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.yanximin.site/tags/Java/"}]},{"title":"HTTP和HTTPS区别","slug":"http-https","date":"2017-09-13T02:34:48.000Z","updated":"2018-04-08T13:13:53.000Z","comments":true,"path":"2017/09/13/http-https/","link":"","permalink":"http://blog.yanximin.site/2017/09/13/http-https/","excerpt":"","text":"HTTP和HTTPSHTTP和HTTPS概念HTTP（Hypertext Transfer Protocol over Secure Socket Layer）：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。默认端口80。 HTTPS（Hypertext Transfer Protocol over Secure Socket Layer）：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。默认端口443。 HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 HTTPS和HTTP的区别HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。 HTTPS和HTTP的区别主要如下： https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 HTTPS的工作原理 客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。 Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。 客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。 Web服务器利用自己的私钥解密出会话密钥。 Web服务器利用会话密钥加密与客户端之间的通信。 注意HTTPS协议是工作在TCP协议之上的。 所以一开始的时候必须要建立三次握手连接。 然后才可以将公钥发送至客户端！ 会话密钥是指： 会话密钥（session key）也称为 数据加密密钥 或者工作密钥，是保证用户跟其它计算机或者两台计算机之间安全通信会话而随机产生的加密和解密密钥，它可由通信用户之间进行协商得到。它一般是动态地、仅在需要进行会话数据加密时产生。会话密钥（session key）是保证用户跟其它计算机或者两台计算机之间安全通信会话而随机产生的加密和解密密钥。会话密钥有时称对称密钥，因为同一密钥用于加密和解密。会话密钥可使用CryptDeriveKey函数从杂乱信号数值中导出（这一方法称会话密钥推导方案）。贯穿各个会话始终，这个密钥与各个消息一起传输，并使用接收者的公共密钥加密。由于其大部分安全性依赖于其使用时间的短暂性，会话密钥常常频繁更改。各个消息可能使用不同的会话密钥。 由于会话密钥是一种对称密钥，存在被破解的危险， 所以会经常更改。","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://blog.yanximin.site/tags/网络/"}]},{"title":"微博Tag的抓取","slug":"weibo-tag","date":"2017-09-11T20:49:18.000Z","updated":"2018-04-08T13:13:46.000Z","comments":true,"path":"2017/09/12/weibo-tag/","link":"","permalink":"http://blog.yanximin.site/2017/09/12/weibo-tag/","excerpt":"","text":"问题 抓取页面中的标签内容 方案使用Fiddler获取Cookie 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package crwaler;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.nio.charset.Charset;import java.util.HashMap;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;import org.apache.http.HttpHost;import org.apache.http.client.HttpClient;import org.apache.http.client.config.RequestConfig;import org.apache.http.conn.params.ConnRouteParams;import org.apache.http.impl.client.HttpClients;import util.PostUtils;public class TagUtil &#123; public static void main(String[] args) throws Exception &#123;// Thread.sleep(1000*60*30); BufferedReader br = new BufferedReader(new FileReader(new File(\"detial.csv\"))); BufferedWriter bw = new BufferedWriter(new FileWriter(new File(\"tag.csv\"))); String temp; while((temp=br.readLine())!=null)&#123; String[] strs = temp.split(\",\"); String id = strs[0]; String tag = getTags(id); System.out.println(id); System.out.println(tag); bw.write(temp + \",\" + tag + \"\\n\"); Thread.sleep(4*1000); &#125; br.close(); bw.close(); &#125; private static String getTags(String id)&#123; String url = \"http://weibo.com/p/100306\" + id + \"/info?mod=pedit_more\"; HttpClient httpClient = HttpClients.createDefault(); Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); String ret = PostUtils.sendPost(httpClient, url, map, Charset.forName(\"utf-8\")); try&#123; ret = ret.split(\"标签\")[2]; &#125;catch(Exception e)&#123; return \"\"; &#125; Pattern pattern = Pattern.compile(\"\\\\\\\\t([0-9a-zA-Z\\\\u4e00-\\\\u9fa5]+?)\\\\\\\\t\"); Matcher matcher = pattern.matcher(ret); StringBuilder sb = new StringBuilder(); while(matcher.find())&#123; sb.append(matcher.group(1)+\" \"); &#125; if(sb.length()&gt;0) return sb.substring(0, sb.length()-1); return \"\"; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package util;import java.io.IOException;import java.nio.charset.Charset;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Map;import org.apache.http.HttpHost;import org.apache.http.NameValuePair;import org.apache.http.client.HttpClient;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;public class PostUtils &#123; /** * * @param httpClient * @param url * 请求地址 * @param params * 请求参数 * @param encoding * 编码 * @return */ public static String sendPost(HttpClient httpClient, String url, Map&lt;String, String&gt; params, Charset encoding) &#123; String resp = \"\"; HttpPost httpPost = new HttpPost(url); HttpHost proxy = new HttpHost(\"127.0.0.1\",8888); RequestConfig config = RequestConfig.custom().setProxy(proxy).build(); httpPost.setConfig(config); httpPost.addHeader(\"Host\", \"weibo.com\"); //httpPost.addHeader(\"Connection\",\"keep-alive\"); //httpPost.addHeader(\"Cache-Control\",\"max-age=0\"); httpPost.addHeader(\"Upgrade-Insecure-Requests\",\"1\"); httpPost.addHeader(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.79 Safari/537.36\"); httpPost.addHeader(\"Accept\",\"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\"); httpPost.addHeader(\"DNT\",\"1\"); httpPost.addHeader(\"Referer\",url); httpPost.addHeader(\"Accept-Language\",\"zh-CN,zh;q=0.8\"); httpPost.addHeader(\"Accept-Encoding\", \"gzip, deflate\"); httpPost.addHeader(\"Cookie\",\"你的Cookie\"); boolean redo = false; if (params != null &amp;&amp; params.size() &gt; 0) &#123; List&lt;NameValuePair&gt; formParams = new ArrayList&lt;NameValuePair&gt;(); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; itr = params.entrySet().iterator(); while (itr.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = itr.next(); formParams.add(new BasicNameValuePair(entry.getKey(), entry.getValue())); &#125; UrlEncodedFormEntity postEntity = new UrlEncodedFormEntity(formParams, encoding); httpPost.setEntity(postEntity); &#125; CloseableHttpResponse response = null; try &#123; response = (CloseableHttpResponse) httpClient.execute(httpPost); System.out.println(response.getStatusLine().getStatusCode()); if(response.getStatusLine().getStatusCode() == 302) redo = true; resp = EntityUtils.toString(response.getEntity(), encoding); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (response != null) &#123; try &#123; response.close(); &#125; catch (IOException e) &#123; &#125; &#125; &#125; return resp; &#125; public static String sendGet(HttpClient httpClient, String url,Charset encoding) &#123; String resp = \"\"; HttpGet httpGet = new HttpGet(url); httpGet.setHeader(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36\"); CloseableHttpResponse response = null; try &#123; response = (CloseableHttpResponse) httpClient.execute(httpGet); resp = EntityUtils.toString(response.getEntity()); &#125; catch (Exception e) &#123; &#125; finally &#123; if (response != null) &#123; try &#123; response.close(); &#125; catch (IOException e) &#123; &#125; &#125; &#125; return resp; &#125;&#125;","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://blog.yanximin.site/tags/爬虫/"}]},{"title":"修改Indigo文章页面宽度","slug":"widen-the-article","date":"2017-09-10T19:58:22.000Z","updated":"2018-04-08T13:13:45.000Z","comments":true,"path":"2017/09/11/widen-the-article/","link":"","permalink":"http://blog.yanximin.site/2017/09/11/widen-the-article/","excerpt":"","text":"问题本博客一直在使用indigo作为我们的模板. 但是现在发现了一个问题: 正文的宽度太小了, 有时候无法看全代码! 解决发现indigo的GitHub上面也有人问了同样的问题: 地址. 我给了一个比较不完美的解决方法: 我也有这个问题, 我把hexo-theme-indigo/layout/page.ejs和hexo-theme-indigo/layout/post.ejs中的&lt;div class=&quot;container body-wrap&quot;&gt;标签加上了style=&quot;width: 1000px;&quot;, 但是这样的话, 手机上看就会不能自适应… 可能把帖子顶起来了, 有人在下面贴出了完美的解决方法: (1) 把hexo-theme-indigo/source/css/_partial/variable.less中的@contentWidth: 960px;改成@contentWidth: 90%;, 当然这个大小是自己可调的, 我调成了80%(效果就是本页面显示的样子). (2) 修改config文件, 将cdn设置为false, 关闭CDN加速. (3) 执行hexo clean命令清空缓存, 再去执行hexo g重新构建发布.","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.yanximin.site/tags/Hexo/"}]},{"title":"删除GitHub仓库","slug":"delete-git-repository","date":"2017-09-05T20:22:49.000Z","updated":"2018-04-08T13:13:55.000Z","comments":true,"path":"2017/09/06/delete-git-repository/","link":"","permalink":"http://blog.yanximin.site/2017/09/06/delete-git-repository/","excerpt":"","text":"删除GitHub的仓库1. 登录GitHub, 找到要删除的仓库 2. 点击Settings, 进入仓库的设置界面 3. 点击Delete this repository 删除这个仓库 输入对应的仓库名, 点击确认即可删除(可能会要求输入GitHub的密码).","categories":[],"tags":[]},{"title":"微博用户标识详解","slug":"weibo-userid-containerid","date":"2017-09-05T19:15:27.000Z","updated":"2018-04-08T13:13:48.000Z","comments":true,"path":"2017/09/06/weibo-userid-containerid/","link":"","permalink":"http://blog.yanximin.site/2017/09/06/weibo-userid-containerid/","excerpt":"","text":"微博用户标识详解微博用户id微博主要用三种手段标注用户: 用户昵称: 显示在页面的名字 用户名: 系统中用户的名字 用户Id: 系统中用户的ID编号 其中用户昵称是可以修改的, 剩下两个不可修改. 比方说吾爱破解论坛这个微博用户(http://weibo.com/52pojie),如下图所示:其昵称为吾爱破解论坛, 用户名为52pojie, 用户ID为1780478695. 无论要抓取的微博链接是以用户昵称还是用户名作为标识的, 我们最后都要将其转化为用户ID, 方便后续的处理. 用户containerId通过用户的特定containerId, 我们可以任意一个用户的信息. 比方说其所有发布过的微博和关注好友列表等. 如果只要抓取一个用户所发布的所有微博的话, 则containerId等于107603+UID.比如我们要抓取吾爱破解论坛的微博,则其对应的containerId为1076031780478695. 我们访问以下的链接, 就可以获取到用户的前25条微博. https://m.weibo.cn/api/container/getIndex?page=1&amp;count=25&amp;containerid=1076031780478695 结果如下所示: 从上面我们可以看到, 用户所发的微博已经全部显示在JSON文件之中了, 我们可以根据自己的需求获取到相应的内容. 用户昵称 screen_name 用户ID user.id 所发图片 pics … 各种Id相互转换的代码下面的contianerId指用户微博页面的contianerId uid转contianerId123456789/*** uid转contianerId* @author yanximin* */static String uidToContainerId(String uid)&#123; if(uid==null) throw new IllegalArgumentException(\"uid is null\"); return 107603+uid;&#125; 昵称转contianerId12345678910111213141516171819/** * 昵称转contianerId * @author yanximin * @throws IOException * @throws ClientProtocolException * */static String nicknameToContainerId(String nickname) throws ClientProtocolException, IOException&#123; String url = \"http://m.weibo.com/n/\"+nickname; HttpClient httpClient = HttpClients.createDefault(); HttpPost post = new HttpPost(url); post.setHeader(\"User-Agent\", USER_AGENT); HttpResponse response = httpClient.execute(post); post.abort(); if(response.getStatusLine().getStatusCode()==302)&#123; String cid = response.getLastHeader(\"Location\").getValue().substring(27); return \"107603\" + cid; &#125; return null; &#125; 用户名转contianerId1234567891011121314151617181920/*** 用户名转contianerId* @author yanximin* @throws IOException * @throws ClientProtocolException * */static String usernameToContainerId(String name) throws ClientProtocolException, IOException&#123; String url = \"https://weibo.cn/\"+name; HttpClient httpClient = HttpClients.createDefault(); HttpGet get = new HttpGet(url); get.setHeader(\"User-Agent\", USER_AGENT); HttpResponse response = httpClient.execute(get); String ret = EntityUtils.toString(response.getEntity(), \"utf-8\"); Pattern pattern = Pattern.compile(\"href=\\\"/([\\\\d]*?)/info\\\"\"); Matcher matcher = pattern.matcher(ret); while(matcher.find())&#123; return \"107603\" + matcher.group(1); &#125; return null;&#125;","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://blog.yanximin.site/tags/爬虫/"}]},{"title":"MySql数据库恢复","slug":"database-recovery","date":"2017-09-04T20:51:50.000Z","updated":"2018-04-08T13:13:56.000Z","comments":true,"path":"2017/09/05/database-recovery/","link":"","permalink":"http://blog.yanximin.site/2017/09/05/database-recovery/","excerpt":"","text":"今天网站出现了数据丢失的问题, 主要原因在于网络不稳定导致. 辛亏之前每天都有在每天晚上十二点备份数据库. 恢复数据库的方法很简单. 找到相应的数据库备份文件, 比如backupfile.sql.gz 在shell中输入以下命令1gunzip &lt; backupfile.sql.gz | mysql -u username -p password databasename 其中gunzip用来解压这个文件,然后使用管道传输到MySql中.","categories":[],"tags":[{"name":"网站维护","slug":"网站维护","permalink":"http://blog.yanximin.site/tags/网站维护/"}]},{"title":"四种POST方式的比较","slug":"four-post","date":"2017-09-03T21:09:21.000Z","updated":"2018-04-08T13:13:54.000Z","comments":true,"path":"2017/09/04/four-post/","link":"","permalink":"http://blog.yanximin.site/2017/09/04/four-post/","excerpt":"","text":"转载自http://www.cnblogs.com/aaronjs/p/4165049.html HTTP/1.1 协议规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。其中 POST 一般用来向服务端提交数据，本文主要讨论 POST 提交数据的几种方式。 我们知道，HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样：123&lt;method&gt; &lt;request-url&gt; &lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; 协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。 但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。下面就正式开始介绍它们。 application/x-www-form-urlencoded这应该是最常见的 POST 提交数据的方式了。浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）： 123POST http://www.example.com HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=utf-8title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3 首先，Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。例如 PHP 中，_POST[&#39;title&#39;] 可以获取到title的值, _POST[&#39;sub&#39;] 可以得到 sub 数组。 很多时候，我们用 Ajax 提交数据时，也是使用这种方式。例如 JQuery 和 QWrap 的 Ajax，Content-Type 默认值都是application/x-www-form-urlencoded;charset=utf-8。 multipart/form-data这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 form 的 enctyped 等于这个值。直接来看一个请求示例：POST ttp://www.example.com HTTP/1.1 1234567891011121314151617Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;text&quot;title------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;Content-Type: image/pngPNG ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 mutipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 –boundary 开始，紧接着内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。关于 mutipart/form-data 的详细定义，请前往 rfc1867 查看。 这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。 上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段原生 form 表单也只支持这两种方式。但是随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。 application/jsonapplication/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。 JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。记得我几年前做一个项目时，需要提交的数据层次非常深，我就是把数据 JSON 序列化之后来提交的。不过当时我是把 JSON 字符串作为 val，仍然放在键值对里，以 x-www-form-urlencoded 方式提交。 Google 的 AngularJS 中的 Ajax 功能，默认就是提交 JSON 字符串。例如下面这段代码： 1234567var data = &#123;'title':'test', 'sub' : [1,2,3]&#125;;$http.post(url, data).success(function(result) &#123;...&#125;); 最终发送的请求是： 12345POST http://www.example.com HTTP/1.1Content-Type: application/json;charset=utf-8&#123;&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]&#125; 这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好。但也有些服务端语言还没有支持这种方式，例如 php 就无法通过 $_POST 对象从上面的请求中获得内容。这时候，需要自己动手处理下：在请求头中 Content-Type 为 application/json 时，从 php://input 里获得原始输入流，再 json_decode 成对象。一些 php 框架已经开始这么做了。 当然 AngularJS 也可以配置为使用 x-www-form-urlencoded 方式提交数据。如有需要，可以参考这篇文章(http://victorblog.com/2012/12/20/make-angularjs-http-service-behave-like-jquery-ajax/)。 text/xml它是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。典型的 XML-RPC 请求是这样的： 1234567891011121314151617181920POST http://www.example.com HTTP/1.1Content-Type: text/xml&lt;!--?xml version=&quot;1.0&quot;?--&gt;&lt;methodcall&gt;&lt;methodname&gt;examples.getStateName&lt;/methodname&gt;&lt;params&gt;&lt;param&gt;&lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt;&lt;/params&gt;&lt;/methodcall&gt; XML-RPC 协议简单、功能够用，各种语言的实现都有。它的使用也很广泛，如 WordPress 的 XML-RPC Api，搜索引擎的 ping 服务等等。JavaScript 中，也有现成的库支持以这种方式进行数据交互，能很好的支持已有的 XML-RPC 服务。不过，我个人觉得 XML 结构还是过于臃肿，一般场景用 JSON 会更灵活方便。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.yanximin.site/tags/Java/"}]},{"title":"使用Java下载大文件","slug":"java-download","date":"2017-09-03T20:51:12.000Z","updated":"2018-04-08T13:13:52.000Z","comments":true,"path":"2017/09/04/java-download/","link":"","permalink":"http://blog.yanximin.site/2017/09/04/java-download/","excerpt":"","text":"主要思路是将大文件分解成若干个小文件进行下载. 本功能由两个类实现:DownLoadManager和DownloadThreadTask实现. 其中DownLoadManager类主要负责下载任务的初始化和调度, DownloadThreadTask主要负责处理下载任务. 用到的主要工具类有 org.apache.http.impl.client.CloseableHttpClient 模拟httpClient客户端发送http请求，可以控制到请求文件的字节位置。 BufferedInputStream都熟悉，用它接受请求来的流信息缓存。 RandomAccessFile文件随机类，可以向文件写入指定位置的流信息。 代码如下: DownLoadManager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package util;import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;import java.net.HttpURLConnection;import java.net.URL;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import org.apache.commons.lang.exception.ExceptionUtils;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * 文件下载管理类 */public class DownLoadManager&#123; private static final Logger LOGGER = LoggerFactory.getLogger(DownLoadManager.class); /** * 每个线程下载的字节数 */ private long unitSize = 1000 * 1024; private ExecutorService taskExecutor = Executors.newFixedThreadPool(10); private CloseableHttpClient httpClient; public DownLoadManager() &#123; PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager(); cm.setMaxTotal(100); httpClient = HttpClients.custom().setConnectionManager(cm).build(); &#125; public static void main(String[] args) throws IOException &#123; new DownLoadManager().doDownload(); &#125; /** * 启动多个线程下载文件 */ public void doDownload() throws IOException &#123; //要下载的url String remoteFileUrl = \"http://cn-sdjn-cu-v-04.acgvideo.com/vg4/e/60/21029304-1.mp4?expires=1504513500&amp;platform=pc&amp;ssig=4-pYfuQHUKppz3XGrw6Hnw&amp;oi=1032322900&amp;nfa=T7l/1XWXSxfil4KoioiGpQ==&amp;dynamic=1&amp;hfa=2073962963&amp;hfb=Yjk5ZmZjM2M1YzY4ZjAwYTMzMTIzYmIyNWY4ODJkNWI=\"; String localPath = \"E://temp//\"; String fileName = new URL(remoteFileUrl).getFile(); System.out.println(\"远程文件名称：\" + fileName); fileName = fileName.substring(fileName.lastIndexOf(\"/\") + 1, fileName.length()).replace(\"%20\", \" \"); System.out.println(\"本地文件名称：\" + fileName); long fileSize = this.getRemoteFileSize(remoteFileUrl); this.createFile(localPath + System.currentTimeMillis() + fileName, fileSize); Long threadCount = (fileSize / unitSize) + (fileSize % unitSize != 0 ? 1 : 0); long offset = 0; CountDownLatch end = new CountDownLatch(threadCount.intValue()); if (fileSize &lt;= unitSize) &#123;// 如果远程文件尺寸小于等于unitSize DownloadThreadTask downloadThread = new DownloadThreadTask(remoteFileUrl, localPath + fileName, offset, fileSize, end, httpClient); taskExecutor.execute(downloadThread); &#125; else &#123;// 如果远程文件尺寸大于unitSize for (int i = 1; i &lt; threadCount; i++) &#123; DownloadThreadTask downloadThread = new DownloadThreadTask(remoteFileUrl, localPath + fileName, offset, unitSize, end, httpClient); taskExecutor.execute(downloadThread); offset = offset + unitSize; &#125; if (fileSize % unitSize != 0) &#123;// 如果不能整除，则需要再创建一个线程下载剩余字节 DownloadThreadTask downloadThread = new DownloadThreadTask(remoteFileUrl, localPath + fileName, offset, fileSize - unitSize * (threadCount - 1), end, httpClient); taskExecutor.execute(downloadThread); &#125; &#125; try &#123; end.await(); &#125; catch (InterruptedException e) &#123; LOGGER.error(\"DownLoadManager exception msg:&#123;&#125;\", ExceptionUtils.getFullStackTrace(e)); e.printStackTrace(); &#125; taskExecutor.shutdown(); LOGGER.debug(\"下载完成！&#123;&#125; \", localPath + fileName); &#125; /** * 获取远程文件尺寸 */ private long getRemoteFileSize(String remoteFileUrl) throws IOException &#123; long fileSize = 0; HttpURLConnection httpConnection = (HttpURLConnection) new URL(remoteFileUrl).openConnection(); //使用HEAD方法 httpConnection.setRequestMethod(\"HEAD\"); int responseCode = httpConnection.getResponseCode(); if (responseCode &gt;= 400) &#123; LOGGER.debug(\"Web服务器响应错误!\"); return 0; &#125; String sHeader; for (int i = 1;; i++) &#123; sHeader = httpConnection.getHeaderFieldKey(i); if (sHeader != null &amp;&amp; sHeader.equals(\"Content-Length\")) &#123; System.out.println(\"文件大小ContentLength:\" + httpConnection.getContentLength()); fileSize = Long.parseLong(httpConnection.getHeaderField(sHeader)); break; &#125; &#125; return fileSize; &#125; /** * 创建指定大小的文件 */ private void createFile(String fileName, long fileSize) throws IOException &#123; File newFile = new File(fileName); RandomAccessFile raf = new RandomAccessFile(newFile, \"rw\"); raf.setLength(fileSize); raf.close(); &#125;&#125; DownloadThreadTask1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package util;import java.io.BufferedInputStream;import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;import java.util.concurrent.CountDownLatch;import org.apache.commons.lang.exception.ExceptionUtils;import org.apache.http.client.ClientProtocolException;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.protocol.BasicHttpContext;import org.apache.http.protocol.HttpContext;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * 负责文件下载的类 */public class DownloadThreadTask implements Runnable &#123; private static final Logger LOGGER = LoggerFactory.getLogger(DownloadThreadTask.class); /** * 待下载的文件 */ private String url = null; /** * 本地文件名 */ private String fileName = null; /** * 偏移量 */ private long offset = 0; /** * 分配给本线程的下载字节数 */ private long length = 0; private CountDownLatch end; private CloseableHttpClient httpClient; private HttpContext context; /** * @param url * 下载文件地址 * @param fileName * 另存文件名 * @param offset * 本线程下载偏移量 * @param length * 本线程下载长度 */ public DownloadThreadTask(String url, String file, long offset, long length, CountDownLatch end, CloseableHttpClient httpClient) &#123; this.url = url; this.fileName = file; this.offset = offset; this.length = length; this.end = end; this.httpClient = httpClient; this.context = new BasicHttpContext(); LOGGER.debug(\"偏移量=\" + offset + \";字节数=\" + length); &#125; public void run() &#123; try &#123; HttpGet httpGet = new HttpGet(this.url); httpGet.addHeader(\"Range\", \"bytes=\" + this.offset + \"-\" + (this.offset + this.length - 1)); httpGet.addHeader(\"Referer\", \"http://api.bilibili.com\"); CloseableHttpResponse response = httpClient.execute(httpGet, context); BufferedInputStream bis = new BufferedInputStream(response.getEntity().getContent()); byte[] buff = new byte[1024]; int bytesRead; File newFile = new File(fileName); RandomAccessFile raf = new RandomAccessFile(newFile, \"rw\"); while ((bytesRead = bis.read(buff, 0, buff.length)) != -1) &#123; raf.seek(this.offset); raf.write(buff, 0, bytesRead); this.offset = this.offset + bytesRead; &#125; raf.close(); bis.close(); &#125; catch (ClientProtocolException e) &#123; LOGGER.error(\"DownloadThread exception msg:&#123;&#125;\", ExceptionUtils.getFullStackTrace(e)); &#125; catch (IOException e) &#123; LOGGER.error(\"DownloadThread exception msg:&#123;&#125;\", ExceptionUtils.getFullStackTrace(e)); &#125; finally &#123; end.countDown(); LOGGER.info(end.getCount() + \" is go on!\"); System.out.println(end.getCount() + \" is go on!\"); &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.yanximin.site/tags/Java/"}]},{"title":"面试记录","slug":"interview","date":"2017-08-12T21:10:11.000Z","updated":"2018-04-08T13:13:53.000Z","comments":true,"path":"2017/08/13/interview/","link":"","permalink":"http://blog.yanximin.site/2017/08/13/interview/","excerpt":"","text":"面试记录2017.8.14 百度 百度运维团队面试的地点在百度科技园K2一楼大厅里。里面都是面试的，不知道是不是为同一个部门。面试官好像不是搞Java的，面的问题中没有包含任何Java的内容而且不清楚SSH框架。主要问了一下项目的事情： EM999中的架构，数据库设计，功能设计等等。询问了具体实现细节，系统是否包含自学习功能等。 在网易实习的情况，爬虫的架构和性能等。 介绍完上面的内容之后差不多过了一个半小时。 最后问了一道编程题。 一个人上台阶，一次可以走1步或者2步，问走到第n个台阶有多少种走法。 这是Leetcode和牛客网上的一道原题，用斐波那契数列就可以解决。 总结：面试官可能没搞过Java或者没接触过Java的一些框架，如何使他们快速地了解这些框架的特性，继而清楚我们所做系统的内容和价值。","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://blog.yanximin.site/tags/面试/"}]},{"title":"Java nio","slug":"java-nio","date":"2017-08-07T23:05:48.000Z","updated":"2018-04-08T13:13:51.000Z","comments":true,"path":"2017/08/08/java-nio/","link":"","permalink":"http://blog.yanximin.site/2017/08/08/java-nio/","excerpt":"","text":"转载自http://ifeve.com/overview/原始英文地址: http://tutorials.jenkov.com/java-nio/overview.html Java NIO 由以下几个核心部分组成： Channels Buffers Selectors虽然Java NIO 中除此之外还有很多类和组件，但在我看来，Channel，Buffer 和 Selector 构成了核心的API。其它组件，如Pipe和FileLock，只不过是与三个核心组件共同使用的工具类。因此，在概述中我将集中在这三个组件上。其它组件会在单独的章节中讲到。 Channel 和 Buffer基本上，所有的 IO 在NIO 中都从一个Channel 开始。Channel 有点象流。 数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。这里有个图示： Channel和Buffer Channel和Buffer有好几种类型。下面是JAVA NIO中的一些主要Channel的实现： FileChannel DatagramChannel SocketChannel ServerSocketChannel 正如你所看到的，这些通道涵盖了UDP 和 TCP 网络IO，以及文件IO。 与这些类一起的有一些有趣的接口，但为简单起见，我尽量在概述中不提到它们。本教程其它章节与它们相关的地方我会进行解释。 以下是Java NIO里关键的Buffer实现： ByteBuffer CharBuffer DoubleBuffer FloatBuffer IntBuffer LongBuffer ShortBuffer这些Buffer覆盖了你能通过IO发送的基本数据类型：byte, short, int, long, float, double 和 char。 Java NIO 还有个 MappedByteBuffer，用于表示内存映射文件， 我也不打算在概述中说明。 SelectorSelector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。例如，在一个聊天服务器中。 这是在一个单线程中使用一个Selector处理3个Channel的图示： Selector和Channel 下面是NIO的一些代码1234567891011121314151617181920212223242526272829303132333435363738394041public void testNio() throws IOException &#123; // 打开文件 RandomAccessFile file = new RandomAccessFile(\"data/uid.txt\", \"rw\"); // 获取Channel FileChannel channel = file.getChannel(); // 得到一个大小为48的Buffer ByteBuffer byteBuffer = ByteBuffer.allocate(48); // Channel开始向Buffer添加数据, byteCount返回的为byteBuffer真实读取到的大小,此时 postion = // byteCount int byteCount = channel.read(byteBuffer); while (byteCount != -1) &#123; System.out.println(\"read:\" + byteCount); // buffer 启动写模式 limit=position, position=0, // buffer只能从postion~limit(不包含limit)之间读取数据 byteBuffer.flip(); // hasRemaining()方法判断position&lt;limit while (byteBuffer.hasRemaining()) &#123; // get()方法返回position所对应的值,position++; System.out.println((char) byteBuffer.get()); &#125; byteBuffer.clear(); byteCount = channel.read(byteBuffer); &#125; file.close();&#125; public void testTransfer() throws IOException &#123; // fromChannel打开fromFile.txt RandomAccessFile fromFile = new RandomAccessFile(\"fromFile.txt\", \"rw\"); FileChannel fromChannel = fromFile.getChannel(); // toChannel打开toFile.txt RandomAccessFile toFile = new RandomAccessFile(\"toFile.txt\", \"rw\"); FileChannel toChannel = toFile.getChannel(); long position = 0; //Returns the current size of this channel's file. long count = fromChannel.size(); // 開始Channel之間的轉化 toChannel.transferFrom(fromChannel, position, count); fromFile.close(); toFile.close();&#125; ifeve NIO系列教程地址Java NIO系列教程（一） Java NIO 概述Java NIO系列教程（二） ChannelJava NIO系列教程（三） BufferJava NIO系列教程（四） Scatter/GatherJava NIO系列教程（五） 通道之间的数据传输Java NIO系列教程（六） SelectorJava NIO系列教程（七） FileChannelJava NIO系列教程（八） SocketChannelJava NIO系列教程（九） ServerSocketChannelJava NIO系列教程（十） Java NIO DatagramChannelJava NIO系列教程（十一） PipeJava NIO系列教程（十二） Java NIO与IO","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.yanximin.site/tags/Java/"}]},{"title":"Java 反射机制初探","slug":"reflect-1","date":"2017-08-04T00:29:02.000Z","updated":"2018-04-08T13:13:49.000Z","comments":true,"path":"2017/08/04/reflect-1/","link":"","permalink":"http://blog.yanximin.site/2017/08/04/reflect-1/","excerpt":"","text":"Java 反射机制反射(Reflect)是Java语言中的重要的特性. Java框架中的绝大多数都使用了反射. 理解框架必须要精通反射的实现和原理. 在java.lang.reflect中, Java提供了一些列反射的类. 其中, 最常用的几个类分别为Class(这个类在java.lang包下), Method, Field, Constructor. 从字面意思上来看, 上面几个类分别对应了Java语言中的类, 方法, 字段, 构造方法. 通过学习使用这几个类, 可以让我们了解Java反射的过程和使用. ClassClass在java.lang, 在Java文档中,对Class类的描述如下 Instances of the class Class represent classes and interfaces in a running Java application. An enum is a kind of class and an annotation is a kind of interface. Every array also belongs to a class that is reflected as a Class object that is shared by all arrays with the same element type and number of dimensions. The primitive Java types (boolean, byte, char, short, int, long, float, and double), and the keyword void are also represented as Class objects.Class has no public constructor. Instead Class objects are constructed automatically by the Java Virtual Machine as classes are loaded and by calls to the defineClass method in the class loader. 从上面我们可以看到Class是Java类的对象. 从Class的实例中, 我们可以操纵Java指定的类. 而且Class类没有构造函数, 只能从一些特定途径生成类对象. 下面代码展示了如何获取一个类对象,首先我们声明一个Student类, 该类是一个普通的类. 下面的所有代码不外加说明的话, 都在此类的基础上展开. 1234567891011121314151617181920212223242526272829303132package reflect;public class Student &#123; private int sId; private int sName; public int getsId() &#123; return sId; &#125; public void setsId(int sId) &#123; this.sId = sId; &#125; public int getsName() &#123; return sName; &#125; public void setsName(int sName) &#123; this.sName = sName; &#125; private void say()&#123; System.out.println(\"hello\"); &#125; public void play()&#123; System.out.println(\"play\"); &#125; public Student() &#123; &#125; public Student(int id)&#123; this.sId = id; &#125; public Student(int id, int sname)&#123; this.sId = id; this.sName = sname; &#125;&#125; 使用类全称获取类对象 1Class clazz = Class.forName(\"reflect.Student\"); 使用类名获取类对象 1Class clazz = Student.class 使用实例获得类对象 12Student s = new Student();Class clazz = s.getClass(); 上述三种方式都可以获取Student的Class对象. 目前来说, 第一种使用类名的字符串获取类对象更加常用. 在一个类对象中有一个方法特别值得注意:newInstance(). 这个方法从字面上就可以很好理解: 产生一个该类的实例.12Class clazz = Class.forName(\"reflect.Student\");Object o = clazz.newInstance(); 但是这个方法只能调用无参构造函数. 当需要调用带参构造函数时或者类中没有无参构造函数时, 就不能用了. 幸好Java提供了Constructor类去调用其他的构造函数. ConstructorConstructor在java.lang.reflect包中. 在Java文档中,对Constructor类的描述如下 Constructor provides information about, and access to, a single constructor for a class.Constructor permits widening conversions to occur when matching the actual parameters to newInstance() with the underlying constructor’s formal parameters, but throws an IllegalArgumentException if a narrowing conversion would occur. 正如上面所说, Constructor是为了解决调用带参构造函数的时候使用, 当然它也可以用来调用无参构造函数. Constructor相当于Class中的newInstance()函数的升级版本.具体用法如下12345678910111213141516Constructor[] constructors = clazz.getConstructors();for(int i=0;i&lt;constructors.length;i++)&#123; Method getIdMethod = clazz.getMethod(\"getsId\"); System.out.println(constructors[i].getName()+\" \"+constructors[i].getParameterCount()); if(constructors[i].getParameterCount()==0)&#123; Object o = constructors[i].newInstance(); System.out.println(getIdMethod.invoke(o)); &#125; else if(constructors[i].getParameterCount()==1)&#123; Object o = constructors[i].newInstance(1); System.out.println(getIdMethod.invoke(o)); &#125;else&#123; Object o = constructors[i].newInstance(2,3); System.out.println(getIdMethod.invoke(o)); &#125;&#125; MethodMethod在java.lang.reflect包中. 在Java文档中,对Method类的描述如下: A Method provides information about, and access to, a single method on a class or interface. The reflected method may be a class method or an instance method (including an abstract method).A Method permits widening conversions to occur when matching the actual parameters to invoke with the underlying method’s formal parameters, but it throws an IllegalArgumentException if a narrowing conversion would occur. Method类是对Java类方法的抽象. 具体使用方法和示例代码如下12345678910Method playMethod = clazz.getMethod(\"play\");playMethod.invoke(clazz.newInstance()); Method[] allMethod = clazz.getDeclaredMethods();for(int i=0;i&lt;allMethod.length;i++)&#123; System.out.println(allMethod[i].getName()+\" \"+allMethod[i].getParameterCount());&#125; Method sayMethod = clazz.getDeclaredMethod(\"say\");sayMethod.setAccessible(true);sayMethod.invoke(clazz.newInstance());sayMethod.setAccessible(false); 注意到这句话sayMethod.setAccessible(true), 目的是让调用者有权限去执行类中的非public方法(或者权限不够的方法). FieldField在java.lang.reflect包中. 在Java文档中,对Field类的描述如下: A Field provides information about, and dynamic access to, a single field of a class or an interface. The reflected field may be a class (static) field or an instance field.A Field permits widening conversions to occur during a get or set access operation, but throws an IllegalArgumentException if a narrowing conversion would occur. Field类是对Java类字段的抽象. 具体使用方法和示例代码如下12345678910Field[] fields = clazz.getDeclaredFields();for(int i=0;i&lt;fields.length;i++)&#123; System.out.println(fields[i].getName());&#125; Object o = clazz.newInstance();Method m = clazz.getMethod(\"setsId\", int.class);System.out.println(m.getName());m.invoke(o, 1);Field sidField = clazz.getDeclaredField(\"sId\");System.out.println(sidField.getInt(o)); 以上就是Java反射中的四个比较重要和基础的类. reflect包中还有许多重要的类, 比方说AOP的实现工具InvocationHandler动态代理等等. 理解基本的反射工具可以让我们更好地了解Java语言的特性和Java框架的原理.","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.yanximin.site/tags/Java/"}]},{"title":"vscode中使用markdown","slug":"mark-down-for-vscode","date":"2017-07-31T18:58:53.000Z","updated":"2018-04-08T13:13:50.000Z","comments":true,"path":"2017/08/01/mark-down-for-vscode/","link":"","permalink":"http://blog.yanximin.site/2017/08/01/mark-down-for-vscode/","excerpt":"","text":"转载自http://www.cnblogs.com/rengised/p/6985031.html vscode 是微软推出一款轻量级的文本编辑工具，类似于sublime，由于其拥有丰富的插件，安装使用也非常简单，所以深受广大程序员的喜爱。 markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 印象笔记 是一款具有笔记、写作、日程管理等诸多功能为一体的强大、易用型笔记本，拥有非常丰富的插件，其中比较好用的有印象笔记·剪藏，马克飞象，具体如何使用，请自行查阅相关资料。 markdown有许多衍生产品，本文主要针对大家比较熟知的印象笔记为例，说明如何在vscode中使用markdown语法编辑文章，同时将文章同步到印象笔记中。 安装配置步骤：1.准备工作。本机已安装vscode、印象笔记或者国际版Evernote，如果没有安装请自行安装以上软件。同时，您已经注册了印象笔记或者国际版Evernote的账号。 2.安装插件。在vscode中安装EverMonkey，Auto-Open Markdown Preview。 vscode安装插件可以从左侧的工具栏中选择Extensions，或者使用快捷键Ctrl+Shift+X。EverMonkey插件的作用是将vscode中的文件同步到印象笔记或者国际版Evernote。Auto-Open Markdown Preview插件的作用是在vscode中，当你打开*.md格式的文件时，自动开启预览，方便你在编辑的过程中实时的看到结果。 Auto-Open Markdown Preview 预览效果 3.EverMonkey配置说明。EverMonkey插件是本文的重点，该插件主要负责将vscode中的文章同步到印象笔记。在vscode中安装完EverMonkey插件后，我们安装官方说明，来一步一步的配置。 a.获取token、noteStoreUrl。快捷键Ctrl+Shift+P，打开command，输入ever token，这里我使用的是国际版Evernote，所以我选择的是International。 b.输入你的印象笔记的账号密码，然后授权，就可以看到token、noteStoreUrl。 c.将 token、noteStoreUrl配置到vscode的用户设置里面。步骤为File --&gt; Preferences --&gt; Settings，左边是系统默认设置，右边是用户自定义设置，在右侧配置token、noteStoreUrl，按照标准的json格式输入，key和value都需要加英文的双引号。 evermonkey.token: your developer tokenevermonkey.noteStoreUrl: your API url d.完成以上步骤，基本就算ok了，建议重启一下vscode，然后输入快捷键Ctrl+Shift+P打开command,输入ever sync，左下角显示synchronize successfully!(第一次同步可能有点慢，请耐心等待一下)，代表EverMonkey插件已经和印象笔记通信成功！如果报错，请去git issue 上面先找是否已经有人提过该问题，如果没有，你可以开个issue给作者。一般你遇到的问题，很多人也遇到了，请在close 里面仔细查找。 e.上传vscode本地文件。新建本地文件，后缀为.md。在文件内容的最上方输入一下内容。12345678--- title: 文件名称 tags: 标签（多个标签用逗号分隔） notebook: （所属的目录）---//下面是正文内容... # xxx 完成文章内容编写之后，输入Ctrl+Shift+P打开command,输入ever publish,提示成功后，就可以在印象笔记客户端看到文章加入到了指定的目录里（如果客户端没有自动更新，请尝试手动更新）,快速提交文章的快捷键是Alt+P。 重要提示：如果报Evernote Error: 5 - Note.title，错误（这个错误坑了好一会）。说明是换行符有问题，请将vscode右下角的换行符从CRLF切换成LF,然后再次执行ever publish，就会有blogs&gt;&gt;vscode中使用印象笔记 created successfully.提示。如果还有错误，请到git issue查找相关问题。 Auto-Open Markdown Preview 预览效果 4.将Preview 设置为github风格vscode 默认的将Preview预览风格是黑黑的，如上面的截图。如果想更改为github风格的样式，请执行如下步骤： a.下载github风格的css到本地，并放置相应的目录，本文推荐放置在vscode安装目录里，如D:/Program Files (x86)/Microsoft VS Code/resources/app/extensions/markdown/media/。 b.设置用户配置文件,File --&gt; Preferences --&gt; Settings,添加如下配置信息，请填入你下载的css文件的路径和名称（我这里的文件名叫userStyle.css）。123&quot;markdown.styles&quot;: [ &quot;file:///D:/Program Files (x86)/Microsoft VS Code/resources/app/extensions/markdown/media/userStyle.css&quot;], github 样式效果图 总结：马克飞象是一款非常好用的印象笔记插件，完全可以胜任以上所有功能，而且界面非常华丽，使用也很简单，但是，要收费。。。 之前用sublime的时候，就使用过相关插件，在sublime 里面实现编辑文章，同步到印象笔记。现在使用vscode比较多，就试试看有没有相关的功能，结果是肯定的（vscode这么优秀，怎能没有呢）。所以就尝试了一下，但是，遇到了个坑，就是Evernote Error: 5 - Note.title，查了半天说是CRLF切换成LF，我也确实在用户配置里面设置了，但是，就是不生效。最后，无意间发现，右下角显示的还是CRLF,然后尝试着点了一下，竟然可以改为LF,再然后呢，就没有然后了，OK了。 虽然费了一大会功夫，但是还是有收获的，就是，这个不要钱。。。 还有一个功能是马克飞象、印象笔记做不到的，印象笔记的内容保存在哪里我们并不知道，如果你想将这些内容同步到git上面，貌似是没有办法的。而使用vscode写*.md，文件内容都是在你指定的目录中，你可以随时将这些文件add,commit,push到git上面，是不是很方便。。。 ps:这篇文章我就是用上述方法编辑的，非常方便，而且我直接push到我的git仓库了。在git页面，直接复制该dom的html源码，贴到博客园就可以自动呈现格式化后的样子（虽然代码块、区域文本显示不太正常），还是很方便。如果照片加载不全或者失败，可以直接访问本文git页面。","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://blog.yanximin.site/tags/Markdown/"},{"name":"vscode","slug":"vscode","permalink":"http://blog.yanximin.site/tags/vscode/"}]},{"title":"我是如何搭建起这个网站的","slug":"HowToBuildAWebSite","date":"2017-07-24T11:51:15.000Z","updated":"2018-04-08T13:13:57.000Z","comments":true,"path":"2017/07/24/HowToBuildAWebSite/","link":"","permalink":"http://blog.yanximin.site/2017/07/24/HowToBuildAWebSite/","excerpt":"","text":"本文只是做个记录 前期准备域名 域名（Domain Name），是由一串用点分隔的字符组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置，地理上的域名，指代有行政自主权的一个地方区域）。域名是一个IP地址上有“面具” 。一个域名的目的是便于记忆和沟通的一组服务器的地址（网站，电子邮件，FTP等）。 这个博客使用的域名为(blog.yanximin.site)是从阿里云上直接购买得到. 第一年四块钱(很实惠有没有), 但是今年就已经变成了40块钱(坑…). VPS VPS（Virtual Private Server 虚拟专用服务器）技术，将一台服务器分割成多个虚拟专享服务器的优质服务。实现VPS的技术分为容器[1] 技术，和虚拟化技术[2] 。在容器或虚拟机中，每个VPS都可分配独立公网IP地址、独立操作系统、实现不同VPS间磁盘空间、内存、CPU资源、进程和系统配置的隔离，为用户和应用程序模拟出“独占”使用计算资源的体验。VPS可以像独立服务器一样，重装操作系统，安装程序，单独重启服务器。VPS为使用者提供了管理配置的自由，可用于企业虚拟化，也可以用于IDC资源租用。 VPS服务器是在搬瓦工上购买,一个月十块钱(1000G流量,10G硬盘). 当服务器的同时,还能顺便FQ,可以说相当划算. VPS上直接使用Bandwagon提供的镜像,安装了CentOS 6. 顺便说一下,他们家的VPS提供了安装ShawdowSocks的脚本,一键安装,十分方便. 博客搭建Hexo本博客使用Hexo框架搭建的.除此之外,使用了indigo 作为网站的前端模板. Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 而inidigo模板主要有以下的特色 仅支持 IE10+ 等现代浏览器。 去 jQuery，更轻。相信现代浏览器的原生兼容性。 使用 Less 作为 css 预处理器，需要安装 hexo-renderer-less。 添加了英文字体支持 Roboto。 添加了一些波纹效果。By Waves 无前端依赖的分享实现。 基于静态数据的站内搜索，无第三方侵入。 支持文章打赏。 Nginx目前,网站通过Hexo生成静态页面,部署在Nginx上.(之前部署在Apache上面,但是存在着一些性能和权限的问题). 使用如下的脚本在Cent OS上安装Nginx 1234567891011121314151617181920212223242526272829303132333435363738#!/bin/bashPATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATH#安装依赖环境yum install -y patch openssl make cmake gcc gcc-c++ gcc-g77 flex bison file libtool libtool-libs autoconf kernel-devel libjpeg libjpeg-devel libpng libpng-devel libpng10 libpng10-devel gd gd-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glib2 glib2-devel bzip2 bzip2-devel libevent libevent-devel ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel libidn libidn-devel openssl openssl-devel vim-minimal nano fonts-chinese gettext gettext-devel ncurses-devel gmp-devel pspell-devel unzip libcap diffutils#安装PCREwget http://downloads.sourceforge.net/project/pcre/pcre/8.36/pcre-8.36.tar.gztar zxf pcre-8.36.tar.gzcd pcre-8.36/./configure &amp;&amp; make &amp;&amp; make installcd ../#安装NGINXwget http://nginx.org/download/nginx-1.6.3.tar.gztar zxf nginx-1.6.3.tar.gzcd nginx-1.6.3/./configure --user=nobody --group=nobody --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-ipv6 --with-http_sub_module --with-http_spdy_modulemake &amp;&amp; make installcd ../ln -s /usr/local/lib/libpcre.so.1 /libln -s /usr/local/nginx/sbin/nginx /usr/bin/nginxrm -f /usr/local/nginx/conf/nginx.confmkdir -p /home/wwwroot/defaultchmod +w /home/wwwroot/defaultmkdir -p /home/wwwlogschmod 777 /home/wwwlogschown -R nobody:nobody /home/wwwroot/defaultwget -c http://soft.vpser.net/lnmp/ext/init.d.nginxcp init.d.nginx /etc/init.d/nginxchmod +x /etc/init.d/nginxchkconfig --level 345 nginx on/sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT/sbin/iptables-saveldconfigwget -c http://redbook.qiniudn.com/nginx.confmv nginx.conf /usr/local/nginx/conf//etc/init.d/nginx start 执行完上述脚本之后，还得修改/usr/local/nginx/conf/nginx.conf文件，修改结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101user root;worker_processes auto;error_log /home/wwwlogs/nginx_error.log crit;pid /usr/local/nginx/logs/nginx.pid;worker_rlimit_nofile 51200;events &#123; use epoll; worker_connections 51200; multi_accept on; &#125;http &#123; include mime.types; default_type application/octet-stream; server_names_hash_bucket_size 128; client_header_buffer_size 32k; large_client_header_buffers 4 32k; client_max_body_size 50m; sendfile on; tcp_nopush on; keepalive_timeout 60; tcp_nodelay on; gzip on; gzip_comp_level 4; gzip_min_length 1k; gzip_buffers 4 16k; gzip_proxied any; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; server_tokens off; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 256k; proxy_connect_timeout 5; proxy_read_timeout 60; proxy_send_timeout 5; proxy_buffer_size 16k; proxy_buffers 4 64k; proxy_busy_buffers_size 128k; proxy_temp_file_write_size 128k; log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;;server &#123; listen 80 default; #listen [::]:80 default ipv6only=on; server_name since1989.org geek.wasai.org; index index.html index.htm index.php; root /root/hexo/public; #error_page 404 /404.html; location ~ [^/]\\.php(/|$) &#123; # comment try_files $uri =404; to enable pathinfo try_files $uri =404; fastcgi_pass unix:/tmp/php-cgi.sock; fastcgi_index index.php; include fastcgi.conf; #include pathinfo.conf; &#125; location /nginx_status &#123; stub_status on; access_log off; &#125; location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 30d; &#125; location ~ .*\\.(js|css)?$ &#123; expires 12h; &#125; access_log /home/wwwlogs/access.log access; &#125;include vhost/*.conf;&#125; 重启Nginx之后，我们的博客服务就可以完美地运行了","categories":[],"tags":[{"name":"网站维护","slug":"网站维护","permalink":"http://blog.yanximin.site/tags/网站维护/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.yanximin.site/tags/Linux/"},{"name":"Hexo","slug":"Hexo","permalink":"http://blog.yanximin.site/tags/Hexo/"}]},{"title":"使用WebMagic定制爬虫","slug":"WebMagic","date":"2017-07-24T09:28:47.000Z","updated":"2018-04-08T13:13:56.000Z","comments":true,"path":"2017/07/24/WebMagic/","link":"","permalink":"http://blog.yanximin.site/2017/07/24/WebMagic/","excerpt":"","text":"使用WebMagic定制爬虫 WebMagic是一个简单灵活的Java爬虫框架。基于WebMagic，你可以快速开发出一个高效、易维护的爬虫。 WebMagic的总体架构如下图所示 Downloader Downloader负责从互联网上下载页面，以便后续处理。WebMagic默认使用了Apache HttpClient作为下载工具。 PageProcessor PageProcessor负责解析页面，抽取有用信息，以及发现新的链接。WebMagic使用Jsoup作为HTML解析工具，并基于其开发了解析XPath的工具Xsoup。 在这四个组件中，PageProcessor对于每个站点每个页面都不一样，是需要使用者定制的部分。 Scheduler Scheduler负责管理待抓取的URL，以及一些去重的工作。WebMagic默认提供了JDK的内存队列来管理URL，并用集合来进行去重。也支持使用Redis进行分布式管理。 除非项目有一些特殊的分布式需求，否则无需自己定制Scheduler。 Pipeline Pipeline负责抽取结果的处理，包括计算、持久化到文件、数据库等。WebMagic默认提供了“输出到控制台”和“保存到文件”两种结果处理方案。 Pipeline定义了结果保存的方式，如果你要保存到指定数据库，则需要编写对应的Pipeline。对于一类需求一般只需编写一个Pipeline。 根据WebMagic的文档我们能够很快写出一个爬虫。比如下面就是一个爬取糗事百科的简单爬虫Demo1234567891011121314151617181920212223242526272829303132import java.util.List;import us.codecraft.webmagic.Page;import us.codecraft.webmagic.Site;import us.codecraft.webmagic.Spider;import us.codecraft.webmagic.pipeline.ConsolePipeline;import us.codecraft.webmagic.processor.PageProcessor;public class QSBKPageProcesser implements PageProcessor&#123; private Site site = Site.me() .addHeader(\"User-Agent\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1) QQBrowser/6.0\") .setDomain(\"www.qiushibaike.com\").setTimeOut(5000).setRetryTimes(5); public void process(Page page) &#123; String url = page.getUrl().toString(); if(url.contains(\"article\"))&#123; //解析内容界面 System.out.println(page.getHtml().xpath(\"//div[@class='content']/text()\").toString()); &#125;else&#123; //解析列表界面 List&lt;String&gt; list = page.getHtml().xpath(\"//a[@class='contentHerf']/@href\").all(); page.addTargetRequests(list); &#125; &#125; public Site getSite() &#123; return this.site; &#125; public static void main(String[] args) &#123; Spider spider = Spider.create(new QSBKPageProcesser()).addPipeline(new ConsolePipeline()); for(int i=1;i&lt;9;i++)&#123; spider.addUrl(\"https://www.qiushibaike.com/8hr/page/\"+i+\"/?s=4996915\"); &#125; spider.run(); &#125;&#125; 最后爬虫的输出结果如下 get page: https://www.qiushibaike.com/8hr/page/1/?s=4996915 get page: https://www.qiushibaike.com/8hr/page/2/?s=4996915 get page: https://www.qiushibaike.com/8hr/page/3/?s=4996915 get page: https://www.qiushibaike.com/8hr/page/4/?s=4996915 get page: https://www.qiushibaike.com/8hr/page/5/?s=4996915 get page: https://www.qiushibaike.com/8hr/page/6/?s=4996915 get page: https://www.qiushibaike.com/8hr/page/7/?s=4996915 get page: https://www.qiushibaike.com/8hr/page/8/?s=4996915 那天去海边游泳，有一位大哥穿着上衣游，我不禁问他：“大哥，为什么你不光膀子游，衣服贴在身上多难受！”大哥脱了上衣给我看，身体上面有文胸的白色?迹。我正惊疑不定，大哥抹了一把脸说：“我前天撩起背心晒日光浴，没想到晒成这样，怪我没经验.....” get page: https://www.qiushibaike.com/article/119336220 小学放假的一天，爸爸让我在家好好写作业，怕我偷看电视，就把总闸拉下来，去地里干活了。但是，架不住我聪明啊。等他们走了，我自己偷偷的合上闸看电视。为了怕他们发现电视后壳发热，我提前一段时间就关了电视。可是，那顿打我还是没有逃过去，我忘了电表是会动的！ get page: https://www.qiushibaike.com/article/119337633 三个宿舍舍友出去聚餐，十一个人正好一桌，结账的时候约好大家各人掏出一张银行卡给服务员抽一张刷，服务员抽到第四张余额不足的时候终于发飙了 get page: https://www.qiushibaike.com/article/119337499 嫂子炸乎乎的打来电话：你哥摊上大事了！被人给告了！我一惊，忙安慰她：别着急，有话好好说，啥事谁告的？她：你八岁的大侄子告的呀，揍了他一顿，就跑到街头派.出所告你哥虐待儿童，你哥正在所里接受教育呢…… get page: https://www.qiushibaike.com/article/119337859 LZ农村的割…… 小时候和老妈 我弟一起去上山砍柴，砍累了就坐在树下乘凉 ，我弟就趴树上去摇树枝玩，突然…… 树上掉下一条蛇落在我头上，当时我和蛇都惊呆了……呆了……了 get page: https://www.qiushibaike.com/article/119335791 在家无聊，想去看个电影，到电影院买票，一张45，给了售票员一张一百，她居然找我10块，我手里拿着钱，和售票员对视五秒后…她用非常惊讶的表情问我：你一个人看电影？ …靠 有谁规定看电影必须两个人么！ 你妹的 get page: https://www.qiushibaike.com/article/119336589 爷爷年轻的时候脾气比较暴躁，喝醉酒就打奶奶，奶奶一直忍气吞声的过日子。现在儿女都在外面安家落户，70多岁的爷爷还是跟奶奶生活在老家，不愿意来城里跟我们一起住。昨晚爷爷又打电话过来：儿子啊，你快管管你娘吧，这个星期已经揍了我三回，我现在打不过他啊。 get page: https://www.qiushibaike.com/article/119337603 可见，使用WebMagic构建一个爬虫是十分便捷的，不逊色于Python的Scrapy。:)","categories":[],"tags":[{"name":"WebMagic","slug":"WebMagic","permalink":"http://blog.yanximin.site/tags/WebMagic/"},{"name":"爬虫","slug":"爬虫","permalink":"http://blog.yanximin.site/tags/爬虫/"}]},{"title":"三个方便查看JVM信息的工具","slug":"three-tools-for-jvm","date":"2017-06-30T02:32:18.000Z","updated":"2018-04-08T13:13:48.000Z","comments":true,"path":"2017/06/30/three-tools-for-jvm/","link":"","permalink":"http://blog.yanximin.site/2017/06/30/three-tools-for-jvm/","excerpt":"","text":"1 JPSJPS是jdk提供的一个查看当前Java进程的小工具， 可以看做是JavaVirtual Machine Process Status Tool的缩写。 比方说上图，有两个Java进程，分别为Eclipse和JPS本身。 2 JSTACKjstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息。 使用Jstack可以很方便地查看死锁，以及出处。 3 JVISUALVM一个功能强大的JVM可视化工具 查看概况 查看资源使用概况 查看内存使用情况和GC 还有其他很多功能","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.yanximin.site/tags/Java/"}]},{"title":"服务器近阶段遇到的问题和解决方法","slug":"problem-of-server","date":"2017-06-22T01:06:34.000Z","updated":"2018-04-08T13:13:49.000Z","comments":true,"path":"2017/06/22/problem-of-server/","link":"","permalink":"http://blog.yanximin.site/2017/06/22/problem-of-server/","excerpt":"","text":"近阶段，我们服务器一直处于不稳定的状态。主要现象有： 网站页面无法打开。 静态图片无法打开 一般为内存溢出或者泄露 修改的方向为Java或者Tomcat方面 网站应用无法正常连接数据库，进而无法进行登录等操作。 网站应用无法使用MySQL数据库 一般为连接池资源耗尽 少数情况下为数据库账号密码出现偏差 数据库连接池频繁出现死锁问题。 C3P0和Spring可能存在问题 对其进行配置来减少死锁出现的情况 我们针对上述现象，主要有如下的解决方法 定时重启网站。 Windows 计算机&gt;管理&gt;任务计划程序概述&gt;创建基本任务。 Linux 使用Shell脚本或者使用Crontab程序创建定时任务。 增加Tomcat连接数。 在server.xml文件中配置。 &lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; maxThreads=&quot;1000&quot; minSpareThreads=&quot;200&quot; acceptCount=&quot;100&quot; maxIdleTime=&quot;30000&quot; URIEncoding=&quot;UTF-8&quot; redirectPort=&quot;8443&quot; /&gt; 增加Hibernate连接池连接数。 在ApplicationContext.xml文件中配置。 &lt;property name=&quot;maxPoolSize&quot; value=&quot;500&quot; /&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;100&quot; /&gt; &lt;property name=&quot;initialPoolSize&quot; value=&quot;200&quot; /&gt; &lt;property name=&quot;maxIdleTime&quot; value=&quot;60&quot; /&gt; &lt;property name=&quot;acquireIncrement&quot; value=&quot;5&quot;&gt;&lt;/property&gt; &lt;property name=&quot;idleConnectionTestPeriod&quot; value=&quot;60&quot;&gt;&lt;/property&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;5&quot;&gt;&lt;/property&gt; 增加JVM内存以及改变GC方法。 在catlina.xml 文件中配置。 set JAVA_OPTS=%JAVA_OPTS% -server -Xmx4550m -Xms4550m -Xmn2g -XX:PermSize=756m -XX:MaxPermSize=756m -Xss512k -XX:ParallelGCThreads=8 -XX:-DisableExplicitGC -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:SurvivorRatio=8 检查可能会导致内存泄漏问题的代码。 在DAO层进行数据库操作的时候，如果用到了HibernateSupport类中的getSession()方法，则最后应该使用releaseSession()方法来释放连接。经过上述操作之后，一个数据库连接才能被数据库连接池重用。 修改Hibernate参数来减少死锁发生的频率。 在ApplicationContext.xml文件中配置。 &lt;property name=&quot;checkoutTimeout&quot; value=&quot;100&quot;/&gt; &lt;property name=&quot;maxStatements&quot; value=&quot;0&quot;/&gt;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.yanximin.site/tags/Java/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://blog.yanximin.site/tags/Tomcat/"}]},{"title":"Markdown 语法说明","slug":"MAKEDOWN","date":"2016-08-31T15:32:03.000Z","updated":"2018-04-08T13:13:57.000Z","comments":true,"path":"2016/08/31/MAKEDOWN/","link":"","permalink":"http://blog.yanximin.site/2016/08/31/MAKEDOWN/","excerpt":"","text":"&lt;&lt; 访问 Wow!Ubuntu NOTE: This is Simplelified Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to Markdown: Syntax. 声明： 这份文档派生(fork)于繁体中文版，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里查看它的源文件。「繁体中文版的原始文件可以查看这里 。」–By @riku 注： 本项目托管于 GitCafe上，请通过”派生”和”合并请求”来帮忙改进本项目。 Markdown 语法说明 (简体中文版) / (点击查看快速入门) 概述 宗旨 兼容 HTML 特殊字符自动转换 区块元素 段落和换行 标题 区块引用 列表 代码区块 分隔线 区段元素 链接 强调 代码 图片 其它 反斜杠 自动链接 感谢 Markdown 免费编辑器 概述 宗旨 Markdown 的目标是实现「易读易写」。 可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。 总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 兼容 HTML Markdown 语法的目标是：成为一种适用于网络的书写语言。 Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。 要制约的只有一些 HTML 区块元素――比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;p&gt; 标签。 例子如下，在 Markdown 文件里加上一段 HTML 表格： 这是一个普通段落。 &lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 这是另一个普通段落。 请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的*强调*会没有效果。 HTML 的区段（行内）标签如 &lt;span&gt;、&lt;cite&gt;、&lt;del&gt; 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 &lt;a&gt; 或 &lt;img&gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。 和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。 特殊字符自动转换 在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &amp;lt; 和 &amp;amp;。 &amp; 字符尤其让网络文档编写者受折磨，如果你要打「AT&amp;T」 ，你必须要写成「AT&amp;amp;T」。而网址中的 &amp; 字符也要转换。比如你要链接到： http://images.google.com/images?num=30&amp;q=larry+bird 你必须要把网址转换写为： http://images.google.com/images?num=30&amp;amp;q=larry+bird 才能放到链接标签的 href 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。 Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 &amp; 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 &amp;amp;。 所以你如果要在文档中插入一个版权符号 ©，你可以这样写： &amp;copy; Markdown 会保留它不动。而若你写： AT&amp;T Markdown 就会将它转为： AT&amp;amp;T 类似的状况也会发生在 &lt; 符号上，因为 Markdown 允许 兼容 HTML ，如果你是把 &lt; 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写： 4 &lt; 5 Markdown 将会把它转换为： 4 &amp;lt; 5 不过需要注意的是，code 范围内，不论是行内还是区块， &lt; 和 &amp; 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 &lt; 和 &amp; 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。） 区块元素 段落和换行 一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。 「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 &lt;br /&gt; 标签。 如果你确实想要依赖 Markdown 来插入 &lt;br /&gt; 标签的话，在插入处先按入两个以上的空格然后回车。 的确，需要多费点事（多加空格）来产生 &lt;br /&gt; ，但是简单地「每个换行都转换为 &lt;br /&gt;」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。 标题 Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： This is an H1 ============= This is an H2 ------------- 任何数量的 = 和 - 都可以有效果。 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： # 这是 H1 ## 这是 H2 ###### 这是 H6 你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）： # 这是 H1 # ## 这是 H2 ## ### 这是 H3 ###### 区块引用 Blockquotes Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt; ： &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, &gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. &gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse &gt; id sem consectetuer libero luctus adipiscing. Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ： &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： &gt; This is the first level of quoting. &gt; &gt; &gt; This is nested blockquote. &gt; &gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： &gt; ## 这是一个标题。 &gt; &gt; 1. 这是第一行列表项。 &gt; 2. 这是第二行列表项。 &gt; &gt; 给出一些例子代码： &gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。 列表 Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记： * Red * Green * Blue 等同于： + Red + Green + Blue 也等同于： - Red - Green - Blue 有序列表则使用数字接着一个英文句点： 1. Bird 2. McHale 3. Parish 很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为： &lt;ol&gt; &lt;li&gt;Bird&lt;/li&gt; &lt;li&gt;McHale&lt;/li&gt; &lt;li&gt;Parish&lt;/li&gt; &lt;/ol&gt; 如果你的列表标记写成： 1. Bird 1. McHale 1. Parish 或甚至是： 3. Bird 1. McHale 8. Parish 你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。 如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。 要让列表看起来更漂亮，你可以把内容用固定的缩进整理好： * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 但是如果你懒，那也行： * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 &lt;p&gt;标签包起来，举例来说： * Bird * Magic 会被转换为： &lt;ul&gt; &lt;li&gt;Bird&lt;/li&gt; &lt;li&gt;Magic&lt;/li&gt; &lt;/ul&gt; 但是这个： * Bird * Magic 会被转换为： &lt;ul&gt; &lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符： 1. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. 2. Suspendisse id sem consectetuer libero luctus adipiscing. 如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许： * This is a list item with two paragraphs. This is the second paragraph in the list item. You&apos;re only required to indent the first line. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. * Another item in the same list. 如果要在列表项目内放进引用，那 &gt; 就需要缩进： * A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符： * 一列表项包含一个列表区块： &lt;代码写在这&gt; 当然，项目列表很可能会不小心产生，像是下面这样的写法： 1986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。 1986\\. What a great season. 代码区块 和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;pre&gt; 和 &lt;code&gt; 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入： 这是一个普通段落： 这是一个代码区块。 Markdown 会转换成： &lt;p&gt;这是一个普通段落：&lt;/p&gt; &lt;pre&gt;&lt;code&gt;这是一个代码区块。 &lt;/code&gt;&lt;/pre&gt; 这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如： Here is an example of AppleScript: tell application &quot;Foo&quot; beep end tell 会被转换为： &lt;p&gt;Here is an example of AppleScript:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot; beep end tell &lt;/code&gt;&lt;/pre&gt; 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如： &lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; 会被转换为： &lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt; &amp;amp;copy; 2004 Foo Corporation &amp;lt;/div&amp;gt; &lt;/code&gt;&lt;/pre&gt; 代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。 分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： * * * *** ***** - - - --------------------------------------- 区段元素 链接 Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： This is [an example](http://example.com/ &quot;Title&quot;) inline link. [This link](http://example.net/) has no title attribute. 会产生： &lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt; an example&lt;/a&gt; inline link.&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no title attribute.&lt;/p&gt; 如果你是要链接到同样主机的资源，你可以使用相对路径： See my [About](/about/) page for details. 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： This is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上一个空格： This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： [id]: http://example.com/ &quot;Optional Title Here&quot; 链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 下面这三种链接的定义都是相同： [foo]: http://example.com/ &quot;Optional Title Here&quot; [foo]: http://example.com/ &apos;Optional Title Here&apos; [foo]: http://example.com/ (Optional Title Here) 请注意：有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。 链接网址也可以用尖括号包起来： [id]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; 你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看： [id]: http://example.com/longish/path/to/resource/here &quot;Optional Title Here&quot; 网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。 链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的： [link text][a] [link text][A] 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成： [Google][] 然后定义链接内容： [Google]: http://google.com/ 由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词： Visit [Daring Fireball][] for more information. 然后接着定义链接： [Daring Fireball]: http://daringfireball.net/ 链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。 下面是一个参考式链接的范例： I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 如果改成用链接名称的方式写： I get 10 times more traffic from [Google][] than from [Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot; 上面两种写法都会产生下面的 HTML。 &lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot; title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; 下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用： I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;) than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or [MSN](http://search.msn.com/ &quot;MSN Search&quot;). 参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。 使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。 强调 Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围，用两个 * 或 _ 包起来的话，则会被转成 &lt;strong&gt;，例如： *single asterisks* _single underscores_ **double asterisks** __double underscores__ 会转成： &lt;em&gt;single asterisks&lt;/em&gt; &lt;em&gt;single underscores&lt;/em&gt; &lt;strong&gt;double asterisks&lt;/strong&gt; &lt;strong&gt;double underscores&lt;/strong&gt; 你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。 强调也可以直接插在文字中间： un*frigging*believable 但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： \\*this text is surrounded by literal asterisks\\* 代码 如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如： Use the `printf()` function. 会产生： &lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt; 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： ``There is a literal backtick (`) here.`` 这段语法会产生： &lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt; 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号： A single backtick in a code span: `` ` `` A backtick-delimited string in a code span: `` `foo` `` 会产生： &lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt; &lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt; 在代码区段内，&amp; 和尖括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段： Please don&apos;t use any `&lt;blink&gt;` tags. 转为： &lt;p&gt;Please don&apos;t use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt; 你也可以这样写： `&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`. 以产生： &lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encoded equivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt; 图片 很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式的图片语法看起来像是： ![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 详细叙述如下： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 文字。 参考式的图片语法则长得像这样： ![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： [id]: url/to/image &quot;Optional title attribute&quot; 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。 其它 自动链接 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： &lt;http://example.com/&gt; Markdown 会转为： &lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt; 邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如： &lt;address@example.com&gt; Markdown 会转成： &lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65; &amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111; &amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61; &amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt; 在浏览器里面，这段字串（其实是 &lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;）会变成一个可以点击的「address@example.com」链接。 （这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。） 反斜杠 Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;em&gt; 标签），你可以在星号的前面加上反斜杠： \\*literal asterisks\\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \\ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 感谢 感谢 leafy7382 协助翻译，hlb、Randylien 帮忙润稿，ethantw 的汉字标准格式・CSS Reset， WM 回报文字错误。 感谢 fenprace，addv。 Markdown 免费编辑器 Windows 平台 MarkdownPad MarkPad Linux 平台 ReText Mac 平台 Mou 在线编辑器 Markable.in Dillinger.io 浏览器插件 MaDe (Chrome) 高级应用 Sublime Text 2 + MarkdownEditing / 教程 *** 如有更好的 Markdown 免费编辑器推荐，请到这里反馈，谢谢！","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://blog.yanximin.site/tags/Markdown/"}]}]}